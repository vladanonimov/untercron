===============================
UnterCron
===============================
Библиотека для шедулинга задач на Питоне.

Пример использования::

    import untercron

    def callback(result):
        print datetime.now().isoformat(), result

    cron = untercron.UnterCron()

    # каждую минуту вызываем лямбду с колбеком
    cron.add_func_task(untercron.Interval(), lambda: 1, callback)

    # каждую чётную минуту вызываем команду ls с колбеком
    cron.add_subprocess_task(
        untercron.Interval(minutes=range(0, 60, 2)),
        ['ls'],
        callback,
    )

    cron.start(daemon_thread=False)  # запускаем
    # что-то делаем
    cron.stop()  # останавливаем

Ещё пара примеров есть в папке `examples`.

Объект untercron.UnterCron
----------------------------
- `start(blocking=False, daemon_thread=True)` - запустить менеджер;
    - `blocking` - если `True`, то запускается, блокируя текущий поток, иначе запускается в отдельном потоке;
    - `daemon_thread` - делать ли поток daemon (имеет смысл только при `blocking=False`)
- `stop()` - останавливает менеджер (имеет смысл только при `blocking=False`);
- `add_func_task(interval, func, callback=None, name=None)` - добавить задачу из питонячего callable;
    - `interval` - когда запускать, объект `Interval`, см. ниже;
    - `func` - callable для запуска;
    - `callback` - колбек, который вызовется после выполнения callable (в том числе и завершившегося исключением). В него будет передан один аргумент - объект с полями:
        - `is_success` - `True`, если исключения не было, `False` - если было;
        - `return_value` - то, что вернул callable (если `is_success == True`, иначе `None`);
        - `exc_info` в случае, если `is_success == False`, иначе `None`;
    - `name` - имя задачи;
- `add_subprocess_task(interval, args, callback=None, popen_kwargs=None, name=None)` - добавить задачу из внешнего исполняемого файла;
    - `interval` - когда запускать, объект `Interval`, см. ниже;
    - `args` - путь к файлу и аргументы, например, ['ls', '-lah'];
    - `callback` - колбек, который вызовется после выполнения callable (в том числе и завершившегося исключением). В него будет передан один аргумент - объект с полями:
        - `is_success` - `True`, если исключения не было, `False` - если было;
        - `return_code` - код возврата из вызова (если `is_success == True`, иначе `None`);
        - `stdout` - вывод в stdout (если `is_success == True`, иначе `None`);
        - `stderr` - вывод в stderr (если `is_success == True`, иначе `None`);
        - `exc_info` в случае, если `is_success == False`, иначе `None`;
    - `popen_kwargs` - дополнительные аргументы в `Popen`;
    - `name` - имя задачи.

Объект untercron.Interval
--------------------------
- `__init__(years=None, months=None, days=None, hours=None, minutes=None, weekdays=None)`: года, месяцы, часы, минуты, дни недели списками. Всё в формате `datetime`, дни недели - в формате `isoweekday`. Если чего-то не передано (`None`), то считается, что подходит любое значение, аналог `*` в `crontab`.


Как в целом работает
---------------------
- запуск внешних процессов делается через `subprocess.Popen`;
- все запуски делаютcя в отдельных потоках, чтобы не блокировать друг друга;
- сам шедулер может быть запущен в отдельном потоке;
- ближайшая задача выбирается через `heap`, но шедулер просыпается каждую секунду - вдрг появились новые задачи;
- следующее время выполнения задачи находится тупейшим алгоритмом: проверяем ближайшие два часа (120 вариантов), если ничего не подходит, откладываем на час, через час повторяем проверку опять. Можно было оптимизировать, оставил так для простоты.

Чего не хватает
-------------------
- удобной обёртки над `untercron.Interval` для частых юзкейсов;
- парсинга кронтаба (не то, что бы не хватает, но было бы неплохо);
- более умного алгоритма нахождения следующего время выполнения задачи;
- возможности посмотреть список добавленных задач;
- логирования;
- тестирования больше, чем на трёх кейсах :-)
